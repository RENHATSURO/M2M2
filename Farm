--!strict
-- ================= SERVICES =================
local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer

-- ================= SETTINGS =================
local autoFarm = false
local moveMode = "Pathfinding" -- Pathfinding | Walk | Tween
local tweenSpeed = 20
local postCollectDelay = 0.2
local tpIfStuck = true

local blacklistDuration = 15

-- anti stuck
local MAX_TARGET_TIME = 6
local STUCK_DISTANCE = 1.5
local STUCK_TIME = 1.2

-- ================= CHARACTER =================
local humanoid: Humanoid?
local rootPart: BasePart?

local function bindCharacter(char: Model)
	humanoid = char:WaitForChild("Humanoid") :: Humanoid
	rootPart = char:WaitForChild("HumanoidRootPart") :: BasePart
end

if player.Character then
	bindCharacter(player.Character)
end

player.CharacterAdded:Connect(function(char)
	task.wait(0.1)
	bindCharacter(char)
end)

-- ================= COINS =================
local cachedCoins: {Instance} = {}
local coinBlacklist: {[Instance]: number} = {}

local function isBlacklisted(coin: Instance): boolean
	local t = coinBlacklist[coin]
	if not t then return false end
	if os.clock() > t then
		coinBlacklist[coin] = nil
		return false
	end
	return true
end

local function getPos(obj: Instance): Vector3
	if obj:IsA("BasePart") then return obj.Position end
	return obj:GetPivot().Position
end

local function refreshCoins()
	table.clear(cachedCoins)
	for _, v in ipairs(workspace:GetDescendants()) do
		if v.Name == "Coin_Server" and not isBlacklisted(v) then
			table.insert(cachedCoins, v)
		end
	end
end

local function getNearestCoin(): Instance?
	if not rootPart then return nil end
	local best, bestDist = nil, math.huge

	for _, coin in ipairs(cachedCoins) do
		if not isBlacklisted(coin) then
			local d = (getPos(coin) - rootPart.Position).Magnitude
			if d < bestDist then
				bestDist = d
				best = coin
			end
		end
	end

	return best
end

-- ================= PATH =================
local function computePath(from: Vector3, to: Vector3): Path?
	local path = PathfindingService:CreatePath()
	path:ComputeAsync(from, to)
	if path.Status == Enum.PathStatus.Success then
		return path
	end
	return nil
end

-- ================= MOVEMENT =================
local activeTween: Tween?

local function safeMoveTo(pos: Vector3, timeout: number): boolean
	if not humanoid or not rootPart then return false end

	humanoid:MoveTo(pos)
	local start = os.clock()

	while os.clock() - start < timeout do
		if not autoFarm then return false end
		if (rootPart.Position - pos).Magnitude < 4 then
			return true
		end
		task.wait(0.05)
	end

	return false
end

local function moveTo(target: Vector3, path: Path?): boolean
	if not humanoid or not rootPart then return false end

	if moveMode == "Tween" then
		if activeTween then activeTween:Cancel() end
		local dist = (rootPart.Position - target).Magnitude
		local time = math.max(dist / tweenSpeed, 0.05)
		activeTween = TweenService:Create(
			rootPart,
			TweenInfo.new(time, Enum.EasingStyle.Linear),
			{CFrame = CFrame.new(target)}
		)
		activeTween:Play()
		activeTween.Completed:Wait()
		return true
	end

	if moveMode == "Walk" then
		return safeMoveTo(target, 2)
	end

	if moveMode == "Pathfinding" and path then
		for _, wp in ipairs(path:GetWaypoints()) do
			if not autoFarm then return false end
			if not safeMoveTo(wp.Position, 2) then
				return false
			end
		end
		return true
	end

	return false
end

-- ================= FARM LOOP =================
task.spawn(function()
	local lockedTarget: Instance?
	local targetStart = 0
	local lastPos: Vector3?
	local lastMove = 0

	while true do
		task.wait(0.05)

		if not autoFarm or not humanoid or not rootPart then
			lockedTarget = nil
			continue
		end

		refreshCoins()

		if not lockedTarget or isBlacklisted(lockedTarget) then
			lockedTarget = getNearestCoin()
			if not lockedTarget then continue end
			targetStart = os.clock()
			lastPos = rootPart.Position
			lastMove = os.clock()
		end

		local coin = lockedTarget
		if not coin then continue end

		-- timeout global
		if os.clock() - targetStart > MAX_TARGET_TIME then
			coinBlacklist[coin] = os.clock() + blacklistDuration
			lockedTarget = nil
			continue
		end

		-- stuck detection
		if lastPos and (rootPart.Position - lastPos).Magnitude > STUCK_DISTANCE then
			lastPos = rootPart.Position
			lastMove = os.clock()
		elseif os.clock() - lastMove > STUCK_TIME then
			if tpIfStuck then
				rootPart.CFrame = CFrame.new(getPos(coin))
			end
			coinBlacklist[coin] = os.clock() + blacklistDuration
			lockedTarget = nil
			continue
		end

		local path
		if moveMode == "Pathfinding" then
			path = computePath(rootPart.Position, getPos(coin))
			if not path then
				coinBlacklist[coin] = os.clock() + blacklistDuration
				lockedTarget = nil
				continue
			end
		end

		moveTo(getPos(coin), path)
		coinBlacklist[coin] = os.clock() + blacklistDuration
		lockedTarget = nil

		if postCollectDelay > 0 then
			task.wait(postCollectDelay)
		end
	end
end)

-- ================= GUI TOGGLE =================
-- (tu peux garder ton GUI actuel, rien Ã  changer ici)

-- ================= GUI =================
local gui = Instance.new("ScreenGui")
gui.ResetOnSpawn = false
gui.Parent = player:WaitForChild("PlayerGui")

local main = Instance.new("Frame", gui)
main.Size = UDim2.fromScale(0.35, 0.45)
main.Position = UDim2.fromScale(0.03, 0.25)
main.BackgroundColor3 = Color3.fromRGB(25,25,25)
main.Active = true
main.Draggable = true

-- Tabs
local tabBar = Instance.new("Frame", main)
tabBar.Size = UDim2.fromScale(1, 0.08)
tabBar.Position = UDim2.fromScale(0,0)
tabBar.BackgroundTransparency = 1

local farmTabBtn = Instance.new("TextButton", tabBar)
farmTabBtn.Size = UDim2.fromScale(0.48,1)
farmTabBtn.Position = UDim2.fromScale(0,0)
farmTabBtn.Text = "Farm"
farmTabBtn.TextScaled = true

local listTabBtn = Instance.new("TextButton", tabBar)
listTabBtn.Size = UDim2.fromScale(0.48,1)
listTabBtn.Position = UDim2.fromScale(0.52,0)
listTabBtn.Text = "Liste"
listTabBtn.TextScaled = true

-- Farm Tab
local farmTab = Instance.new("Frame", main)
farmTab.Size = UDim2.fromScale(1,0.92)
farmTab.Position = UDim2.fromScale(0,0.08)
farmTab.BackgroundTransparency = 1

local farmBtn = Instance.new("TextButton", farmTab)
farmBtn.Size = UDim2.fromScale(0.9,0.12)
farmBtn.Position = UDim2.fromScale(0.05,0.05)
farmBtn.Text = "Auto Farm : OFF"
farmBtn.TextScaled = true

local modeBtn = Instance.new("TextButton", farmTab)
modeBtn.Size = UDim2.fromScale(0.9,0.12)
modeBtn.Position = UDim2.fromScale(0.05,0.2)
modeBtn.Text = "Mode : Pathfinding"
modeBtn.TextScaled = true

-- Sliders for TweenSpeed
local speedLabel = Instance.new("TextLabel", farmTab)
speedLabel.Size = UDim2.fromScale(0.9,0.06)
speedLabel.Position = UDim2.fromScale(0.05,0.35)
speedLabel.Text = "Tween Speed: "..tweenSpeed
speedLabel.TextScaled = true

local speedBar = Instance.new("Frame", farmTab)
speedBar.Size = UDim2.fromScale(0.9,0.03)
speedBar.Position = UDim2.fromScale(0.05,0.42)
speedBar.BackgroundColor3 = Color3.fromRGB(80,80,80)

local speedFill = Instance.new("Frame", speedBar)
speedFill.Size = UDim2.fromScale(0.3,1)
speedFill.BackgroundColor3 = Color3.fromRGB(0,170,255)

-- Delay slider
local delayLabel = Instance.new("TextLabel", farmTab)
delayLabel.Size = UDim2.fromScale(0.9,0.06)
delayLabel.Position = UDim2.fromScale(0.05,0.48)
delayLabel.Text = string.format("Delay: %.2fs", postCollectDelay)
delayLabel.TextScaled = true

local delayBar = Instance.new("Frame", farmTab)
delayBar.Size = UDim2.fromScale(0.9,0.03)
delayBar.Position = UDim2.fromScale(0.05,0.55)
delayBar.BackgroundColor3 = Color3.fromRGB(80,80,80)

local delayFill = Instance.new("Frame", delayBar)
delayFill.Size = UDim2.fromScale(postCollectDelay,1)
delayFill.BackgroundColor3 = Color3.fromRGB(255,170,0)

-- Liste Tab
local listTab = Instance.new("Frame", main)
listTab.Size = UDim2.fromScale(1,0.92)
listTab.Position = UDim2.fromScale(0,0.08)
listTab.BackgroundTransparency = 1
listTab.Visible = false

local scrolling = Instance.new("ScrollingFrame", listTab)
scrolling.Size = UDim2.fromScale(0.9,0.85)
scrolling.Position = UDim2.fromScale(0.05,0.05)
scrolling.BackgroundColor3 = Color3.fromRGB(30,30,30)
scrolling.BorderSizePixel = 0
scrolling.ScrollBarThickness = 6

local layout = Instance.new("UIListLayout", scrolling)
layout.Padding = UDim.new(0,6)

-- ================= UI LOGIC =================
farmTabBtn.MouseButton1Click:Connect(function()
	farmTab.Visible = true
	listTab.Visible = false
end)

listTabBtn.MouseButton1Click:Connect(function()
	farmTab.Visible = false
	listTab.Visible = true
end)

farmBtn.MouseButton1Click:Connect(function()
	autoFarm = not autoFarm
	farmBtn.Text = autoFarm and "Auto Farm : ON" or "Auto Farm : OFF"
	if autoFarm then startFarm() else stopFarm() end
end)

modeBtn.MouseButton1Click:Connect(function()
	moveMode = (moveMode == "Pathfinding" and "Walk") or (moveMode == "Walk" and "Tween") or "Pathfinding"
	modeBtn.Text = "Mode : "..moveMode
end)

-- Slider logic
local draggingSpeed, draggingDelay = false, false

speedBar.InputBegan:Connect(function(i)
	if i.UserInputType == Enum.UserInputType.MouseButton1 then draggingSpeed = true end
end)
delayBar.InputBegan:Connect(function(i)
	if i.UserInputType == Enum.UserInputType.MouseButton1 then draggingDelay = true end
end)
UserInputService.InputEnded:Connect(function(i)
	if i.UserInputType == Enum.UserInputType.MouseButton1 then
		draggingSpeed = false
		draggingDelay = false
	end
end)

RunService.RenderStepped:Connect(function()
	if draggingSpeed then
		local m = player:GetMouse()
		local x = math.clamp((m.X - speedBar.AbsolutePosition.X)/speedBar.AbsoluteSize.X,0,1)
		speedFill.Size = UDim2.fromScale(x,1)
		tweenSpeed = math.floor(5 + x*45)
		speedLabel.Text = "Tween Speed: "..tweenSpeed
	end
	if draggingDelay then
		local m = player:GetMouse()
		local x = math.clamp((m.X - delayBar.AbsolutePosition.X)/delayBar.AbsoluteSize.X,0,1)
		delayFill.Size = UDim2.fromScale(x,1)
		postCollectDelay = math.floor(x*2*100)/100
		delayLabel.Text = string.format("Delay: %.2fs", postCollectDelay)
	end
end)

-- ================= LIST LOOP =================
task.spawn(function()
	while true do
		refreshCoins()
		scrolling:ClearAllChildren()
		for _, coin in ipairs(cachedCoins) do
			local lbl = Instance.new("TextLabel")
			lbl.Size = UDim2.new(1,-8,0,24)
			lbl.BackgroundColor3 = Color3.fromRGB(45,45,45)
			lbl.TextColor3 = isBlacklisted(coin) and Color3.fromRGB(150,150,150) or Color3.new(1,1,1)
			lbl.TextScaled = true
			lbl.Text = coin.Name
			lbl.Parent = scrolling
		end
		task.wait(listRefreshInterval)
	end
end)
